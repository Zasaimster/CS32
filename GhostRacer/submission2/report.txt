1)
Actor.h

Actor:
doSomething(), this function handles all the logic each actor will handle. It's a pure virtual function because all subclasses of Actor will need one, and an Actor class is never created
getWorld(), this function returns a pointer to StudentWorld. I put it in the base subclass because all classes could use the StudentWorld pointer at different times in their logic.
setToNotAlive(), this function sets an actor to not alive. All actors can be declared as dead or alive, so it should be in the base class
getIsAlive(), this function gets whether an actor is alive or not. All actors will need to use this when StudentWorld runs through its move method
getHorizontalSpeed(), returns horizontal speed. All actors have horizontal speeds
setHorizontalSpeed(const double dx), sets horizontal speed. All actors have adjustable speeds
getVertSpeed(), returns vertical speed. All actors have vertical speeds
setVertSpeed(const double dy), sets vertical speed. all actors have adjustable vertical speeds
isCollisionWorthy(), returns whether an actor is collision worthy or not. All actors are either collision worthy or not collision worthy
handleSprayCollision(), has logic to handle a collision with a spray actor. I chose to include this in the actor base class because all actors will need to handle a collision with a spray. However, I made it a virtual function, and in the Actor class I just left the body of the function as empty, so that I don't need to write any code for other actors to ignore the spray collision if they aren't affected by it. If an actor is affected by the spray, they'll have their own re definition of the function in their class
isSprayable(), returns whether an actor is sprayable or not. All actors are sprayable or not sprayable. I made it virtual, but I defined the base class function to return false. All sprayable classes will have a redefinition of the function which will return true;
moveActorRelativeToDive(Actor* driver), this function moves a class relative to the vertical speed of another actor. In our case, this was normally the ghost racer actor, but I thought it was best fit to keep it generic for any actor. I'm keeping this in the Actor class since all classes will move relative to the ghostracer (except the ghostracer, of course)
checkIfActorIsOffScreenAndSetToNotAlive(), this checks if an actor is not on the visual screen anymore. If it isn't, it'll set its isAlive value to false

LivingActor:
adjustHealth(const int deltaHealth), this function adds deltaHealth to an actor's current health and sets its isAlive to false if its health <= 0. I thought it'd be best to keep this in the LivingActor class, since all of its subclasses have health points
handleDeath(), sets an actor's isAlive to false. I thought it'd be best to keep this in this class because all living actors handle death differently. I made this a virtual function, so that all the classes that handle an actor's death with more complexity will be able to redefine the function and add more features to it.
getHealth(), returns health. this class contains health, so it should return it

GhostRacer: (GR)
doSomething(), handles all of ghostracer's tasks
lostTheRound(), this is activated when a ghostracer hits a human pedestrian, and it automatically sets its health to 0, killing it. I thought it'd be best to put in this class because it's easier to directly change GhostRacer's health and values this way
increaseHolyWater(const int num), adds to GR's holy water count. This class contains the holy water variable which is relevant to GR
getCountOfHolyWater() returns holy water count, holy water should also have a getter function
spinDueToOilSlick(), adjusts GR's direction to simulate it slipping on the road, this only affects the GR so it should be in this class
handleDeath(), handle's its death
getSoulsSaved() returns amount of souls saved, getter for soulssaved variable
adjustSoulsSaved(const int num = 1) setter method for soulsSaved variable

BorderLine:
doSomething(), handles its movement 

Pedestrian:
doSomething(), handles all logic and then calls doSomethingSpecificAsPedestrian()
getMovementPlanDistance(), getter for movementplandistance variable. Should be in pedestrian class since both zombie and human peds use it
decrementMovementPlanDistance(), decrements movement plan distance by 1, ""
setMovementPlanDistance(const int newDistance), setter for movementPlanDistance when it needs to be reset, ""
adjustMovementPlan(), this function handles all the logic to create a new movementplan, the logic is same for human and zombie peds so it's best to include it in this class
isSprayable(), returns true to indicate it can be sprayed, needs to be included to indicate it can be sprayed
the spec says to only discuss public member functions, but there's a private function I believe should be mentioned->
overlapsGhostRacer(GhostRacer* gr), handles logic for a specific pedestrian's interaction with a ghostracer (since human and zombie peds have different interactions). I made this pure virtual since there's nothing I can write for it in this class

HumanPed:
handleSprayCollision(), handles all the logic when the human ped intersects with a spray
doSomethingSpecificAsPedestrian(), handles all specific logic for its regular tasks during the move() method

ZombiePed:
decrementTicksUntilGrunt(), decrements value of ticks until next grunt, should be included in this class since only this class deals with grunts
getTicksUntilGrunt(), getter for ticks until grunt variable, ""
setNumberOfTicksUntilGrunt(), setter for ticks until next grunt variable when it needs to be reset, ""
handleSprayCollision(), handles logic when it intersects a holy water spray
handleDeath(), handles logic for when it dies. Only needs to be in this pedestrian class since only this one can die during gameplay
doSomethingSpecificAsPedestrian(), handles all specific logic for its regular tasks during the move() method

ZombieCab:
doSomething(), handles zombie cab's logic during each tick

pseudocode:
if it overlaps with the ghost racer
	if it hasn't damaged it yet
		play the crash sound
		reduce the GR's health
		if the cab's xpos <= GR's xpos
			make horizontal speed -5
			orient the direction to the left
		else
			make the horizontal speed 5
			orient the direction to the right
		set damaged to true
move zombie cab
find the current lane the cab is in 
	if cab's vert speed > GR's vert speed
		call isThereACwActorInFront()
	else
		call isThereACwActorBehind()
adjust movement plan data


calculateLaneEdges(int& leftEdge, int& rightEdge, const int currLane), this function adjusts the values of the leftEdge and rightEdge for the current lane a zombie cab wants to check (lanes 1, 2, 3) when completing calculations, only relevant to this class so I included it in here
handleSprayCollision(), handles intersection with holy water spray
handleDeath(), handles specific logic when the cab dies
determineLane(), returns an int that indicates what lane the cab is in. Used for zombie cab specific calculations, so it is required in this class. This was done by checking if its x coordinate fell in the left third, middle third, or right third of the screen

GhostRacerActivatedObject:
doSomething(), regular method that handles common logic among all subclasses
doSomethingAsAnObject(), method that handles specific logic amoong objects. I made this pure virtual since it only needs to be implemented in its subclasses. This is a boolean function that returns true when an object has an intersection with the GR. Returning true to the doSomething() function will cause it to play the object's specific sound and increas the player's score by the specific amount
getScoreIncrease(), returns a value indicating how much a specific object should increase the score in game. Only needed in this class because no others deal with score like in this one
getSound(), returns a value indicating the sound an object must make when activated. Only needed in this class because no others deal with sound like in this one
getPointerToGhostRacer(), returns a pointer to GR. Helpful since the GR pointer was only stored in this class but not the subclasses

OilSlick:
doSomethingAsAnObject(), handles oil slick's specific tasks per tick and returns true if it intersects with the ghostracer

HealingGoodie:
doSomethingAsAnObject(), handles healing goodie's specific tasks per tick and returns true if it intersects with the ghostracer
handleSprayCollision(), handles logic when it intersects with the holy water spray
isSprayable(), returns true indicating that it can intersect a holy water spray

SoulGoodie:
doSomethingAsAnObject(), handles soul goodie's specific tasks per tick and returns true if it intersects with the ghostracer

HolyWater
doSomethingAsAnObject(), handles holy water's specific tasks per tick and returns true if it intersects with the ghostracer
handleSprayCollision(), handles logic when it intersects with the holy water spray
isSprayable(), returns true indicating that it can intersect a holy water spray

HolyWaterSpray
doSomething(), handles all the logic the spray needs to do during a tick if it is spawned by the GR


StudentWorld.h

ghostRacerWasKilled(), used to change a status variable to indicate that ghostRacer is dead. This will end the level during the move() function
getStringForStats(), returns the entire string that is located at the top of the screen. I implemented this function to make the code look cleaner 
allocateNewSpray(int x, int y, int sd), used to create a new holy water spray. Called by GR when space is clicked
allocateNewHealingGoodie(int x, int y), used to create a new healing goodie. Potentially called by a zombie ped when it dies
allocateNewOilSlick(int x, int y), used to allocate a new oil slick. Potentially called by zombie cab when it dies
checkForAndHandleSprayCollisions(Actor* spray), checks to see if an active spray collides with any sprayable objects. If anything intersects, it'll call its function to handle spray collision and then return right away
addNewBorders(), add new actors according to spec
addNewZombieCabs(), ""
pseudocode:

if the random number generated by what the spec mentions == 0
	determine a random lane (0, 1 or 2)
	find the left most lane x coordinate
	find the right most lane x coordinate
	intialize a startX, startX, startSpeed ints as empty values
	iterate 3 times for each lane
		if a new actor was created, break out of the loop
		make two actor points set as nullptrs (closestToBottom, closestToTop)
		set startX as the center of the current lane
		iterate through all the actors
			if it's collision worthy and fits in the current lane 
				if either of the points are null, set them to the current actor
				if the actor's y coord is < closestToBottom's y coordinate
					closestToBottom = actor
				if the actor's y coord is > closestToTop's y coordinate
					closestToTop = actor
		if ghost racer isn't in the current lane
			if closest to bottom is nullptr or it's y coordinate > VIEW_HEIGHT / 3
				create a new zombie cab at the bottom of the screen in the specified lane
		else 
			if closestToTop isn nullptr or it's y cord is M VIEW_HEIGHT * 2 / 3
				create a new zombie cab at the top of the screenin the specified lane
			
		
		


addNewOilSlicks(), ""
addNewZombiePeds(), ""
addNewHumanPeds(), ""
addNewHolyWaterRefills(), ""
addNewLostSoulGoodies(), ""
isThereACwActorInFront(int currLane, ZombieCab* zc) checks to see if there is a collison worthy actor in front of a zombie cab according to what the spec sheet requires
pseudocode:

calculate edges using calculateLaneEdges()
	for all of the actors
		if actor is not the cab and is collision worthy
			if the x coordinates of the x actor fit into the lane, and the distance between the actor the cab is > distance
				set distance to tempDistance
if distance < 96
	decrease the vertical speed and return true
else
	return false

isThereACwActorBehind(int currLane, ZombieCab* zc) checks to see if there is a collision worthy actor behind a zombie cab according to what the spec sheet requires
pseudocode:

calculate edges using calculateLaneEdges()
	for all of the actors
		if actor is not the cab and is collision worthy
			if the x coordinates of the x actor fit into the lane, and the distance between the actor the cab is > distance
				set distance to tempDistance
if abs(distance) < 96
	decrease the vertical speed and return true
else
	return false


2) I believe I implemented everything required from the project spec 

3) The spec did not specify too much for the zombie cab section when determining lanes, so I made my own function to determine the lane it is currently. The spec did not mention how to add new actors from an actor class, so I made functions inside StudentWorld to specifically allocate memory for specific objects. The spec never mentioned good ways to make the project more object oriented, and I implemented a few functions inside the Actor class before the example skeleton was put out such as the doesOverlap(Actor* a), checkIfActorIsOffScreenAndSetToNotAlive(), and moveActorRelativeToDriver(Actor* driver) functions to help avoid writing a lot of repetitive code. 